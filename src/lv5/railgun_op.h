#ifndef _IV_LV5_RAILGUN_OP_H_
#define _IV_LV5_RAILGUN_OP_H_
#include <cassert>
#include <tr1/cstdint>
#include <tr1/array>
#include "static_assert.h"
namespace iv {
namespace lv5 {
namespace railgun {

#define IV_LV5_RAILGUN_OP_LIST(V)\
V(STOP_CODE)\
V(NOP)\
\
V(POP_TOP)\
V(ROT_TWO)\
V(ROT_THREE)\
V(DUP_TOP)\
V(ROT_FOUR)\
\
V(UNARY_POSITIVE)\
V(UNARY_NEGATIVE)\
V(UNARY_NOT)\
V(UNARY_BIT_NOT)\
\
V(BINARY_ADD)\
V(BINARY_SUBSTRACT)\
V(BINARY_MULTIPLY)\
V(BINARY_DIVIDE)\
V(BINARY_MODULO)\
V(BINARY_LSHIFT)\
V(BINARY_RSHIFT)\
V(BINARY_RSHIFT_LOGICAL)\
V(BINARY_LT)\
V(BINARY_LTE)\
V(BINARY_GT)\
V(BINARY_GTE)\
V(BINARY_INSTANCEOF)\
V(BINARY_IN)\
V(BINARY_EQ)\
V(BINARY_STRICT_EQ)\
V(BINARY_NE)\
V(BINARY_STRICT_NE)\
V(BINARY_BIT_AND)\
V(BINARY_BIT_XOR)\
V(BINARY_BIT_OR)\
\
V(RETURN)\
V(THROW)\
V(TRY)\
V(WITH_SETUP)\
V(WITH_CLEANUP)\
V(FORIN_SETUP)\
V(SWITCH_SETUP)\
V(TRY_CATCH_CLEANUP)\
V(TRY_FINALLY)\
V(RETURN_SUBROUTINE)\
\
V(PUSH_EMPTY)\
V(PUSH_UNDEFINED)\
V(PUSH_TRUE)\
V(PUSH_FALSE)\
V(PUSH_NULL)\
V(PUSH_THIS)\
V(PUSH_ARGUMENTS)\
V(PUSH_ARGUMENTS_STRICT)\
\
V(BUILD_OBJECT)\
V(BUILD_REGEXP)\
\
V(LOAD_ELEMENT)\
V(LOAD_ELEMENT_STRICT)\
V(STORE_ELEMENT)\
V(STORE_ELEMENT_STRICT)\
V(DELETE_ELEMENT)\
V(DELETE_ELEMENT_STRICT)\
V(CALL_ELEMENT)\
V(CALL_ELEMENT_STRICT)\
V(INCREMENT_ELEMENT)\
V(INCREMENT_ELEMENT_STRICT)\
V(DECREMENT_ELEMENT)\
V(DECREMENT_ELEMENT_STRICT)\
V(POSTFIX_INCREMENT_ELEMENT)\
V(POSTFIX_INCREMENT_ELEMENT_STRICT)\
V(POSTFIX_DECREMENT_ELEMENT)\
V(POSTFIX_DECREMENT_ELEMENT_STRICT)\
\
V(STORE_CALL_RESULT)\
V(STORE_CALL_RESULT_STRICT)\
V(DELETE_CALL_RESULT)\
V(DELETE_CALL_RESULT_STRICT)\
V(CALL_CALL_RESULT)\
V(CALL_CALL_RESULT_STRICT)\
V(INCREMENT_CALL_RESULT)\
V(INCREMENT_CALL_RESULT_STRICT)\
V(DECREMENT_CALL_RESULT)\
V(DECREMENT_CALL_RESULT_STRICT)\
V(POSTFIX_INCREMENT_CALL_RESULT)\
V(POSTFIX_INCREMENT_CALL_RESULT_STRICT)\
V(POSTFIX_DECREMENT_CALL_RESULT)\
V(POSTFIX_DECREMENT_CALL_RESULT_STRICT)\
\
V(TYPEOF)\
\
/* opcodes over this requres argument */\
V(HAVE_ARGUMENT)\
\
V(STORE_OBJECT_DATA)\
V(STORE_OBJECT_GET)\
V(STORE_OBJECT_SET)\
\
V(LOAD_NAME)\
V(LOAD_NAME_STRICT)\
V(STORE_NAME)\
V(STORE_NAME_STRICT)\
V(DELETE_NAME)\
/* DELETE_NAME_STRICT is restricted by strict mode */\
V(CALL_NAME)\
V(CALL_NAME_STRICT)\
V(INCREMENT_NAME)\
V(INCREMENT_NAME_STRICT)\
V(DECREMENT_NAME)\
V(DECREMENT_NAME_STRICT)\
V(POSTFIX_INCREMENT_NAME)\
V(POSTFIX_INCREMENT_NAME_STRICT)\
V(POSTFIX_DECREMENT_NAME)\
V(POSTFIX_DECREMENT_NAME_STRICT)\
\
V(LOAD_PROP)\
V(LOAD_PROP_STRICT)\
V(STORE_PROP)\
V(STORE_PROP_STRICT)\
V(DELETE_PROP)\
V(DELETE_PROP_STRICT)\
V(CALL_PROP)\
V(CALL_PROP_STRICT)\
V(INCREMENT_PROP)\
V(INCREMENT_PROP_STRICT)\
V(DECREMENT_PROP)\
V(DECREMENT_PROP_STRICT)\
V(POSTFIX_INCREMENT_PROP)\
V(POSTFIX_INCREMENT_PROP_STRICT)\
V(POSTFIX_DECREMENT_PROP)\
V(POSTFIX_DECREMENT_PROP_STRICT)\
\
V(LOAD_GLOBAL)\
V(LOAD_GLOBAL_STRICT)\
V(STORE_GLOBAL)\
V(STORE_GLOBAL_STRICT)\
V(DELETE_GLOBAL)\
/* DELETE_GLOBAL_STRICT is restricted by strict mode */\
\
V(LOAD_CONST)\
\
V(TYPEOF_NAME)\
\
V(JUMP_FORWARD)\
V(JUMP_SUBROUTINE)\
V(JUMP_IF_FALSE_OR_POP)\
V(JUMP_IF_TRUE_OR_POP)\
V(JUMP_ABSOLUTE)\
V(POP_JUMP_IF_FALSE)\
V(POP_JUMP_IF_TRUE)\
\
V(FORIN_ENUMERATE)\
V(SWITCH_CASE)\
V(SWITCH_DEFAULT)\
V(TRY_CATCH_SETUP)\
\
V(LOAD_FAST)\
V(STORE_FAST)\
V(DELETE_FAST)\
\
V(CALL)\
V(CONSTRUCT)\
\
V(CALL_EVAL)\
\
V(MAKE_FUNCTION)\
\
V(MAKE_CLOSURE)\
V(LOAD_CLOSURE)\
V(LOAD_DEREF)\
V(STORE_DEREF)\
\
V(INIT_ARRAY_ELEMENT)\
V(BUILD_ARRAY)\
\
V(ERROR)\
\
/* opcodes over this requres 2 argument */\
V(EXTENDED_ARG)\

struct ERR {
  enum Type {
    NOT_REFERENCE = 0,
    NUM_OF_ERR
  };
};

struct OP {
#define IV_LV5_RAILGUN_DEFINE_ENUM(V) V,
  enum Type {
    IV_LV5_RAILGUN_OP_LIST(IV_LV5_RAILGUN_DEFINE_ENUM)
    NUM_OF_OP
  };
#undef IV_LV5_RAILGUN_DEFINE_ENUM

#define IV_LV5_RAILGUN_HAS_STRICT_OP(op)\
(\
(op) == LOAD_ELEMENT || \
(op) == STORE_ELEMENT || \
(op) == DELETE_ELEMENT || \
(op) == DELETE_CALL_RESULT || \
(op) == LOAD_NAME || \
(op) == STORE_NAME || \
(op) == LOAD_PROP || \
(op) == STORE_PROP || \
(op) == DELETE_PROP || \
(op) == LOAD_GLOBAL || \
(op) == STORE_GLOBAL \
)

  IV_STATIC_ASSERT(NUM_OF_OP <= 256);

  template<Type op>
  struct HasStrict {
    // strict mode
    static const int value = IV_LV5_RAILGUN_HAS_STRICT_OP(op);
  };

  static inline bool HasStrictOP(uint8_t opcode) {
    return IV_LV5_RAILGUN_HAS_STRICT_OP(opcode);
  }

  static inline bool HasArg(uint8_t opcode) {
    return opcode >= HAVE_ARGUMENT;
  }

  static inline const char* String(int op);
};

#define IV_LV5_RAILGUN_DEFINE_STRINGS(V) #V,
static const std::tr1::array<const char*, OP::NUM_OF_OP + 1> kOPString = { {
  IV_LV5_RAILGUN_OP_LIST(IV_LV5_RAILGUN_DEFINE_STRINGS)
  "NUM_OF_OP"
} };
#undef IV_LV5_RAILGUN_DEFINE_STRINGS

const char* OP::String(int op) {
  assert(0 <= op && op < NUM_OF_OP);
  return kOPString[op];
}

} } }  // namespace iv::lv5::railgun
#endif  // _IV_LV5_RAILGUN_OP_H_
